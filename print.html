<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Notes</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="microprocessors/index.html"><strong aria-hidden="true">1.</strong> Microprocessors</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="microprocessors/history.html"><strong aria-hidden="true">1.1.</strong> History</a></li><li class="chapter-item expanded "><a href="microprocessors/index.html"><strong aria-hidden="true">1.2.</strong> 8086 Microcontroller</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="microprocessors/architecture.html"><strong aria-hidden="true">1.2.1.</strong> Architecture</a></li><li class="chapter-item expanded "><a href="microprocessors/addressing-modes.html"><strong aria-hidden="true">1.2.2.</strong> Addressing Modes</a></li><li class="chapter-item expanded "><a href="microprocessors/registors-and-flags.html"><strong aria-hidden="true">1.2.3.</strong> Registers and Flags</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Notes</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="microcontroller"><a class="header" href="#microcontroller">Microcontroller</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-the-microprocessor-and-computer"><a class="header" href="#introduction-to-the-microprocessor-and-computer">Introduction to the Microprocessor and Computer</a></h1>
<p>The world’s first microprocessor, the Intel 4004, was a 4-bit
microprocessor–programmable controller on a chip. It addressed a mere 4096,
4-bit-wide memory locations. The 4004 instruction set contained only 45
instructions. It was fabricated with the then-current state-of-the-art
P-channel MOSFET technology that only allowed it to execute instructions at the
slow rate of 50 KIPs (kilo-instructions per second).
This was slow when compared to the 100,000 instructions executed per second by
the 30-ton ENIAC computer in 1946. The main difference was that the 4004
weighed much less than an ounce. The main problems with this early microprocessor
were its speed, word width, and memory size.</p>
<h2 id="the-8085-microprocessor"><a class="header" href="#the-8085-microprocessor">The 8085 Microprocessor</a></h2>
<p>In 1977, Intel Corporation introduced an updated version of the 8080—the 8085.
The 8085 was to be the last 8-bit, general-purpose microprocessor developed by
Intel. Although only slightly more advanced than an 8080 microprocessor, the
8085 executed software at an even higher speed. An addition that took 2.0 μs
(500,000 instructions per second on the 8080) required only 1.3 μs (769,230
instructions per second) on the 8085. The main advantages of the 8085 were its
internal clock generator, internal system controller, and higher clock
frequency. This higher level of component integration reduced the 8085’s cost
and increased its usefulness. </p>
<p>The 16-bit microprocessor evolved mainly because of the need for larger memory systems.
The popularity of the Intel family was ensured in 1981, when IBM Corporation decided to use
the 8088 microprocessor in its personal computer. The 16-bit 8086 and 8088 provided 1M byte of memory.</p>
<h2 id="the-80286-microprocessor"><a class="header" href="#the-80286-microprocessor">The 80286 Microprocessor</a></h2>
<p>The 80286 microprocessor (also a 16-bit architecture microprocessor)
was almost identical to the 8086 and 8088, except it addressed a 16M-byte memory system instead
of a 1M-byte system. The instruction set of the 80286 was almost identical to the 8086 and 8088,
except for a few additional instructions that managed the extra 15M bytes of memory. The clock
speed of the 80286 was increased, so it executed some instructions in as little as 250 ns (4.0 MIPs)
with the original release 8.0 MHz version. Some changes also occurred to the internal execution of
the instructions, which led to an eightfold increase in speed for many instructions when compared to
8086/8088 instructions.</p>
<h2 id="the-32-bit-microprocessor"><a class="header" href="#the-32-bit-microprocessor">The 32-Bit Microprocessor</a></h2>
<p>Applications began to demand faster microprocessor speeds, more
memory, and wider data paths. This led to the arrival of the 80386 in 1986 by Intel Corporation.
The 80386 represented a major overhaul of the 16-bit 8086–80286 architecture. The 80386 was
Intel’s first practical 32-bit microprocessor that contained a 32-bit data bus and a 32-bit memory
address.</p>
<p>The 80386 was available in a few modified versions such as the 80386SX, which
addressed 16M bytes of memory through a 16-bit data and 24-bit address bus, and
the 80386SL/80386SLC, which addressed 32M bytes of memory through a 16-bit data
and 25-bit address bus. An 80386SLC version contained an internal cache memory
that allowed it to process data at even higher rates. In 1995, Intel released
the 80386EX microprocessor. The 80386EX microprocessor is called an embedded PC
because it contains all the components of the AT class personal computer on a
single integrated circuit. The 80386EX also contains 24 lines for input/output
data, a 26-bit address bus, a 16-bit data bus, a DRAM refresh controller, and
programmable chip selection logic.</p>
<h2 id="the-80486-microprocessor"><a class="header" href="#the-80486-microprocessor">The 80486 Microprocessor.</a></h2>
<p>In 1989, Intel released the 80486 microprocessor, which incorpo- rated an
80386-like microprocessor, an 80387-like numeric coprocessor, and an 8K-byte
cache memory system into one integrated package. Although the 80486
microprocessor was not radi- cally different from the 80386, it did include one
substantial change. The internal structure of the 80486 was modified from the
80386 so that about half of its instructions executed in one clock instead of
two clocks. Because the 80486 was available in a 50 MHz version, about half of
the instructions executed in 25 ns (50 MIPs). The average speed improvement for
a typical mix of instructions was about 50% over the 80386 that operated at the
same clock speed. Later versions of the 80486 executed instructions at even
higher speeds with a 66 MHz double-clocked version (80486DX2). The
double-clocked 66 MHz version executed instructions at the rate of 66 MHz, with
memory transfers executing at the rate of 33 MHz. (This is why it was called a
double-clocked microprocessor.) A triple-clocked version from Intel, the
80486DX4, improved the internal execution speed to 100 MHz with memory
transfers at 33 MHz. Note that the 80486DX4 microprocessor executed
instructions at about the same speed as the 60 MHz Pentium. It also contained
an expanded 16K-byte cache in place of the standard 8K-byte cache found on
earlier 80486 microprocessors. Advanced Micro Devices (AMD) has produced a
triple-clocked version that runs with a bus speed of 40 MHz and a clock speed
of 120 MHz. The future promises to bring microprocessors that internally
execute instructions at rates of up to 10 GHz or higher.</p>
<h2 id="pentium-ii-and-pentium-xeon-microprocessors"><a class="header" href="#pentium-ii-and-pentium-xeon-microprocessors">Pentium II and Pentium Xeon Microprocessors</a></h2>
<p>The Pentium II microprocessor (released in 1997) represents a new direction for
Intel. Instead of being an integrated circuit as with prior ver- sions of the
microprocessor, Intel has placed the Pentium II on a small circuit board. The
main reason for the change is that the L2 cache found on the main circuit board
of the Pentium was not fast enough to function properly with the Pentium II. On
the Pentium system, the L2 cache oper- ates at the system bus speed of 60 MHz
or 66 MHz. The L2 cache and microprocessor are on a circuit board called the
Pentium II module. This onboard L2 cache operates at a speed of 133 MHz and
stores 512K bytes of information. The microprocessor on the Pentium II module
is actually Pentium Pro with MMX extensions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="microcontroller-1"><a class="header" href="#microcontroller-1">Microcontroller</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>The addressing modes for this powerful family of microprocessors are described
for the real, protected, and flat modes of operation. Real mode memory (DOS
memory) exists at locations 00000H–FFFFFH, the first 1M byte of the memory
system, and is present on all versions of the microprocessor. Protected mode
memory (Windows memory) exists at any location in the entire protected memory
system, but is available only to the 80286–Core2, not to the earlier 8086 or
8088 microprocessors. Protected mode memory for the 80286 contains 16M bytes;
for the 80386–Pentium, 4G bytes; and for the Pentium Pro through the Core2,
either 4G or 64G bytes. With the 64-bit extensions enabled, the Pentium 4
and Core2 address 1T byte of memory in a flat memory model. Windows Vista
or Windows 64 is needed to operate the Pentium 4 or Core2 in 64-bit mode
using the flat mode memory to access the entire 1T byte of memory.</p>
<h1 id="8086"><a class="header" href="#8086">8086</a></h1>
<p><a href="microprocessors/./images/8086_architecture-diagram.jpg">architecture_diagram</a></p>
<ul>
<li>8086 does not have a RAM or ROM inside it. However, it has internal registers for storing intermediate and final results and interfaces with memory located outside it through the System Bus.</li>
<li>It is a 16-bit Integer processor in a 40 pin, Dual Inline Packaged IC.</li>
<li>The size of the internal registers(present within the chip) indicate how much information the processor can operate on at a time (in this case 16-bit registers) and how it moves data around internally within the chip, sometimes also referred to as the internal data bus.</li>
<li>8086 provides the programmer with 14 internal registers, each 16 bits or 2 Bytes wide.</li>
</ul>
<h3 id="memory-segmentation"><a class="header" href="#memory-segmentation">Memory segmentation:</a></h3>
<ul>
<li>To increase execution speed and fetching speed, 8086 segments the memory. </li>
<li>It’s 20 bit address bus can address 1MB of memory, it segments it into 16 64kB segments. </li>
<li>8086 works only with four 64KB segments within the whole 1MB memory.</li>
</ul>
<h3 id="the-internal-architecture-is-divided-into-2-units"><a class="header" href="#the-internal-architecture-is-divided-into-2-units">The internal architecture is divided into 2 units</a></h3>
<ol>
<li>The Bus Interface Unit (BIU)</li>
<li>The Execution Unit (EU)</li>
</ol>
<h2 id="1-the-bus-interface-unit-biu"><a class="header" href="#1-the-bus-interface-unit-biu">1. The Bus Interface Unit (BIU)</a></h2>
<ul>
<li>It provides the interface of 8086 to external memory and I/O devices via the System Bus. It performs various machine cycles such as memory read, I/O read etc. to transfer data between memory and I/O devices. </li>
</ul>
<h3 id="role-of-biu"><a class="header" href="#role-of-biu">Role of BIU</a></h3>
<ul>
<li>It generates the 20 bit physical address for memory access.</li>
<li>It fetches instructions from the memory.</li>
<li>It transfers data to and from the memory and I/O.</li>
<li>Maintains the 6 byte prefetch instruction queue(supports pipelining).</li>
<li>BIU mainly contains the 4 Segment registers, the Instruction Pointer, a prefetch queue and an Address Generation Circuit</li>
</ul>
<h3 id="instruction-pointer-ip"><a class="header" href="#instruction-pointer-ip">Instruction Pointer (IP):</a></h3>
<ul>
<li>It is a 16 bit register. It holds offset of the next instructions in the <strong>Code Segment</strong></li>
<li>IP is incremented after every instruction byte is fetched.</li>
<li>IP gets a new value whenever a branch instruction occurs.</li>
<li>CS is multiplied by 10H to give the 20 bit physical address of the Code Segment.</li>
<li>Address of the next instruction is calculated as <strong>CS x 10H + IP</strong>.</li>
</ul>
<p>Example: </p>
<pre><code>CS = 4321H 
IP = 1000H 
then CS x 10H = 43210H + offset =  44210H  
</code></pre>
<h3 id="code-segment-register"><a class="header" href="#code-segment-register">Code Segment register</a></h3>
<ul>
<li>CS holds the base address for the Code Segment. </li>
<li>All programs are stored in the Code Segment and accessed via the IP(instruction pointer register). </li>
<li>CS register cannot be modified by executing any instruction except branch instructions</li>
</ul>
<h3 id="data-segment-register"><a class="header" href="#data-segment-register">Data Segment register</a></h3>
<p>DS holds the base address for the Data Segment. </p>
<h3 id="stack-segment-register"><a class="header" href="#stack-segment-register">Stack Segment register</a></h3>
<p>SS holds the base address for the Stack Segment. </p>
<h3 id="extra-segment-register"><a class="header" href="#extra-segment-register">Extra Segment register</a></h3>
<p>ES holds the base address for the Extra Segment. </p>
<h3 id="address-generation-circuit"><a class="header" href="#address-generation-circuit">Address Generation Circuit:</a></h3>
<ul>
<li>The BIU has a Physical Address Generation Circuit.</li>
<li>It generates the 20 bit physical address using Segment and Offset addresses using the formula: </li>
</ul>
<pre><code>Physical Address = Segment Address x 10H + Offset Address
</code></pre>
<h3 id="6-byte-pre-fetch-queue"><a class="header" href="#6-byte-pre-fetch-queue">6 Byte Pre-fetch Queue</a></h3>
<ul>
<li>It is a 6-byte FIFO RAM used to implement Pipelining.</li>
<li>Fetching the next instruction (by BIU from CS) while executing the current instruction is called <strong>pipelining</strong>.</li>
<li>BIU fetches the next &quot;six instruction-bytes&quot; from the Code Segment and stores it into the queue. Execution Unit (EU) removes instructions from the queue and executes them.</li>
<li>The queue is refilled when atleast two bytes are empty as 8086 has a 16-bit data bus.</li>
<li>Pipelining fails when a branch occurs, as the pre-fetched instructions are no longer useful. Hence as soon as 8086 detects a branch operation, it clears/discards the entire queue. Now, the next six bytes from the new location (branch address) are fetched and stored in the queue and Pipelining continues.</li>
</ul>
<h2 id="2-the-execution-unit-eu"><a class="header" href="#2-the-execution-unit-eu">2. The Execution Unit (EU)</a></h2>
<p>The main components of the EU are General purpose registers, the ALU, Special purpose registers, Instruction Register and Instruction Decoder and the Flag/Status Register. </p>
<ul>
<li>Fetches instructions from the Queue in BIU, decodes and executes arithmetic and logic operations using the ALU.</li>
<li>Sends control signals for internal data transfer operations within the microprocessor.</li>
<li>Sends request signals to the BIU to access the external module.</li>
<li>It operates with respect to clock cycles (T-states) and not machine cycles.</li>
<li>8086 has four 16 bit general purpose registers AX, BX, CX and DX. Store intermediate values during execution. Each of these have two 8 bit parts (higher and lower). </li>
</ul>
<h4 id="ax-register"><a class="header" href="#ax-register">AX register</a></h4>
<p>It holds operands and results during multiplication and division operations. Also an accumulator during String operations. </p>
<h4 id="bx-register"><a class="header" href="#bx-register">BX register</a></h4>
<p>It holds the memory address (offset address) in indirect addressing modes. </p>
<h4 id="cx-register"><a class="header" href="#cx-register">CX register</a></h4>
<p>It holds count for instructions like loop, rotate, shift and string operations. </p>
<h4 id="dx-register"><a class="header" href="#dx-register">DX register</a></h4>
<p>It is used with AX to hold 32 bit values during multiplication and division. </p>
<h3 id="arithmetic-logic-unit-16-bit"><a class="header" href="#arithmetic-logic-unit-16-bit">Arithmetic Logic Unit (16 bit)</a></h3>
<p>Performs 8 and 16 bit arithmetic and logic operations. </p>
<h3 id="special-purpose-registers-16-bit"><a class="header" href="#special-purpose-registers-16-bit">Special purpose registers (16-bit)</a></h3>
<p><img src="microprocessors/./images/memory-segment.png" alt="memory-segment" /> </p>
<h4 id="--stack-pointersp"><a class="header" href="#--stack-pointersp">- Stack Pointer(SP)</a></h4>
<p>Points to Stack top. Stack is in Stack Segment, used during instructions like PUSH, POP, CALL, RET etc.</p>
<h4 id="--base-pointerbp"><a class="header" href="#--base-pointerbp">- Base Pointer(BP)</a></h4>
<p>BP can hold offset address of any location in the stack segment. It is used to access random locations of the stack.</p>
<h4 id="--source-indexsi"><a class="header" href="#--source-indexsi">- Source Index(SI)</a></h4>
<p>It holds offset address in Data Segment during string operations.</p>
<h4 id="--destination-indexdi"><a class="header" href="#--destination-indexdi">- Destination Index(DI)</a></h4>
<p>It holds offset address in Extra Segment during string operations.</p>
<h3 id="instruction-register-and-instruction-decoder"><a class="header" href="#instruction-register-and-instruction-decoder">Instruction Register and Instruction Decoder</a></h3>
<p>The EU fetches an opcode from the queue into the instruction register. The instruction decoder decodes it and sends the information to the control circuit for execution. </p>
<h3 id="flagstatus-register-16-bits"><a class="header" href="#flagstatus-register-16-bits">Flag/Status register (16 bits):</a></h3>
<p>It has 9 flags that help change or recognize the state of the microprocessor. </p>
<h3 id="6-status-flags"><a class="header" href="#6-status-flags">6 Status flags:</a></h3>
<ol>
<li>
<p>carry flag(CF)
It is set whenever there is a carry {or borrow} out of the MSB of a the result (D7 bit for an 8-bit operation D15 bit for a 16-bit operation)</p>
</li>
<li>
<p>parity flag(PF)
It is set if the result has even parity.</p>
</li>
<li>
<p>auxiliary carry flag(AF)
It is set if a carry is generated out of the Lower Nibble.
It is used only in 8-bit operations like DAA and DAS.</p>
</li>
<li>
<p>zero flag(Z)
It is set if the result is zero.</p>
</li>
<li>
<p>sign flag(S)
It is set if the MSB of the result is 1.
For signed operations, such a number is treated as –ve.</p>
</li>
<li>
<p>overflow flag (O)
It will be set if the result of a signed operation is too large to fit in the number of bits available to represent it. It can be checked using the instruction INTO (Interrupt on Overflow).</p>
</li>
</ol>
<p>Status flags are updated after every arithmetic and logic operation. </p>
<h3 id="3-control-flags"><a class="header" href="#3-control-flags">3 Control flags:</a></h3>
<ol>
<li>
<p>trap flag(TF)
It is used to set the Trace Mode i.e. start Single Stepping Mode.
Here the µP is interrupted after every instruction so that, the program can be debugged.</p>
</li>
<li>
<p>interrupt flag(IF)
It is used to mask (disable) or unmask (enable) the INTR interrupt.</p>
</li>
<li>
<p>direction flag(DF)
If this flag is set, SI and DI are in auto-decrementing mode in String Operations.</p>
</li>
</ol>
<p>These flags can be set or reset using control instructions like CLC, STC, CLD, STD, CLI, STI, etc</p>
<p>The Control flags are used to control certain operations. </p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li>https://lambdageeks.com/8086-microprocessors-pin-diagram/</li>
<li>https://www.geeksforgeeks.org/architecture-of-8086/</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="general-purpose-registers-in-8086-microprocessor"><a class="header" href="#general-purpose-registers-in-8086-microprocessor">General purpose registers in 8086 microprocessor</a></h1>
<p>General purpose registers are used to store temporary data within the microprocessor. There are 8 general purpose registers in 8086 microprocessor.</p>
<p><img src="microprocessors/./images/memory-segment.png" alt="memory-segment" /> </p>
<p>AX, BX, CX, DX are of 16 bits and is divided into two 8-bit registers XH and XL to also perform 8-bit instructions.
SP, BP, SI, DI are of 16 bits and cannot be devided.</p>
<ol>
<li>AX </li>
</ol>
<ul>
<li>This is the accumulator. </li>
<li>It is generally used for arithmetical and logical instructions but in 8086 microprocessor it is not mandatory to have accumulator as the destination operand.
Example:</li>
</ul>
<pre><code>ADD AX, AX  //(AX = AX + AX)
</code></pre>
<ol start="2">
<li>BX </li>
</ol>
<ul>
<li>This is the base register. </li>
<li>It is used to store the value of the offset.
Example:</li>
</ul>
<pre><code>MOV BL, [500] (BL = 500H)
</code></pre>
<ol start="3">
<li>CX </li>
</ol>
<ul>
<li>This is the counter register. </li>
<li>It is used in looping and rotation.
Example:</li>
</ul>
<pre><code>MOV CX, 0005
LOOP
</code></pre>
<ol start="4">
<li>DX </li>
</ol>
<ul>
<li>This is the data register. </li>
<li>It is used in multiplication an input/output port addressing.
Example:</li>
</ul>
<pre><code>MUL BX (DX, AX = AX * BX)
</code></pre>
<ol start="5">
<li>SP (stack pointer)</li>
</ol>
<ul>
<li>It points to the topmost item of the stack.</li>
<li>If the stack is empty the stack pointer will be (FFFE)H.</li>
<li>Stack is in Stack Segment, used during instructions like PUSH, POP, CALL, RET etc.</li>
<li>It’s offset address relative to stack segment.</li>
</ul>
<ol start="6">
<li>BP (base pointer)</li>
</ol>
<ul>
<li>It is primary used in accessing parameters passed by the stack.</li>
<li>It’s offset address relative to stack segment.</li>
</ul>
<ol start="7">
<li>SI (source index register)</li>
</ol>
<ul>
<li>It is used in the pointer addressing of data and as a source in some string related operations.</li>
<li>It’s offset is relative to data segment.</li>
</ul>
<ol start="8">
<li>DI (destination index register)</li>
</ol>
<ul>
<li>It is used in the pointer addressing of data and as a destination in some string related operations.</li>
<li>It’s offset is relative to extra segment.</li>
</ul>
<h4 id=""><a class="header" href="#"></a></h4>
<h3 id="1-sign-flag-s"><a class="header" href="#1-sign-flag-s">1. Sign Flag (S)</a></h3>
<ul>
<li>After any operation if the MSB (B(7)) of the result is 1, it indicates the number is negative and the sign flag becomes set, i.e. 1. If the MSB is 0, it indicates the number is positive and the sign flag becomes reset i.e. 0.</li>
<li>from 00H to 7F, sign flag is 0</li>
<li>from 80H to FF, sign flag is 1</li>
<li>1- MSB is 1 (negative)</li>
<li>0- MSB is 0 (positive)</li>
</ul>
<p>Example:</p>
<p>MVI A 30 (load 30H in register A)
MVI B 40 (load 40H in register B)
SUB B (A = A – B)
These set of instructions will set the sign flag to 1 as 30 – 40 is a negative number.</p>
<p>MVI A 40 (load 40H in register A)
MVI B 30 (load 30H in register B)
SUB B (A = A – B)
These set of instructions will reset the sign flag to 0 as 40 – 30 is a positive number.</p>
<p>Zero Flag (Z) – After any arithmetical or logical operation if the result is 0 (00)H, the zero flag becomes set i.e. 1, otherwise it becomes reset i.e. 0.
00H zero flag is 1.
from 01H to FFH zero flag is 0
1- zero result
0- non-zero result</p>
<p>Example:</p>
<p>MVI A 10 (load 10H in register A)
SUB A (A = A – A)
These set of instructions will set the zero flag to 1 as 10H – 10H is 00H</p>
<p>Auxiliary Carry Flag (AC) – This flag is used in BCD number system(0-9). If after any arithmetic or logical operation D(3) generates any carry and passes on to B(4) this flag becomes set i.e. 1, otherwise it becomes reset i.e. 0. This is the only flag register which is not accessible by the programmer
1-carry out from bit 3 on addition or borrow into bit 3 on subtraction
0-otherwise</p>
<p>Example:</p>
<p>MOV A 2B (load 2BH in register A)
MOV B 39 (load 39H in register B)
ADD B (A = A + B)
These set of instructions will set the auxiliary carry flag to 1, as on adding 2B and 39, addition of lower order nibbles B and 9 will generate a carry.</p>
<p>Parity Flag (P) – If after any arithmetic or logical operation the result has even parity, an even number of 1 bits, the parity register becomes set i.e. 1, otherwise it becomes reset i.e. 0.
1-accumulator has even number of 1 bits
0-accumulator has odd parity</p>
<p>Example:</p>
<p>MVI A 05 (load 05H in register A)
This instruction will set the parity flag to 1 as the BCD code of 05H is 00000101, which contains even number of ones i.e. 2.</p>
<p>Carry Flag (CY) – Carry is generated when performing n bit operations and the result is more than n bits, then this flag becomes set i.e. 1, otherwise it becomes reset i.e. 0.
During subtraction (A-B), if A&gt;B it becomes reset and if (A&lt;B) it becomes set.
Carry flag is also called borrow flag.
1-carry out from MSB bit on addition or borrow into MSB bit on subtraction
0-no carry out or borrow into MSB bit</p>
<p>Example:</p>
<p>MVI A 30 (load 30H in register A)
MVI B 40 (load 40H in register B)
SUB B (A = A – B)
These set of instructions will set the carry flag to 1 as 30 – 40 generates a carry/borrow.</p>
<p>MVI A 40 (load 40H in register A)
MVI B 30 (load 30H in register B)
SUB B (A = A – B)
These set of instructions will reset the sign flag to 0 as 40 – 30 does not generate any carry/borrow.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
